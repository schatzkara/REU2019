# phase 2

import torch
import torch.nn as nn


# from torchsummary import summary


class Expander(nn.Module):
    """
    Class representing the Expander network to be used.
    """

    def __init__(self, ex_name='Viewpoint Expander'):
        super(Expander, self).__init__()
        self.ex_name = ex_name

        # definition of all network layers
        self.conv3d_1a = nn.Conv3d(in_channels=1, out_channels=4, kernel_size=(3, 3, 3),
                                   stride=(1, 1, 1), padding=(1, 1, 1))
        self.conv3d_1b = nn.Conv3d(in_channels=4, out_channels=8, kernel_size=(3, 3, 3),
                                   stride=(1, 1, 1), padding=(1, 1, 1))

        # print('%s Model Successfully Built \n' % self.ex_name)

    def forward(self, x):
        """
        Function to compute a single forward pass through the network, according to the architecture.
        :param x: (tensor) The input tensor from which a video will be generated.
                   Must be a tensor of shape: (bsz, 1536, 7, 7) for this application.
        :return: A tensor representing the video generated by the network.
                 Shape of output is: (bsz, 3, 8/16, 112, 112) for this application.
        """
        # print(x)
        # print(x.size())
        x = self.expand_vp(x)

        x = self.conv3d_1a(x)
        x = self.conv3d_1b(x)

        return x

    def expand_vp(self, vp):
        bsz = vp.size()[0]
        buffer = torch.zeros(bsz, 1, 16, 28, 28)
        # for a in range(bsz):
        for b in range(1):
            for c in range(16):
                for d in range(28):
                    for e in range(28):
                        buffer[:, b, c, d, e] = vp
        return buffer.to('cuda')

# if __name__ == "__main__":
#     print_summary = True
#
#     ex = Expander()
#
#     if print_summary:
#         summary(ex, input_size=(1, 16, 28, 28))
#
